在C++标准库中的`std::sort`函数允许你指定一个自定义的比较函数（或函数对象），这个比较函数用来确定排序的顺序。当你传入一个比较函数`cmp`给`std::sort`时，这个函数会被用来比较数组或容器中的元素，以决定它们的排序顺序。

如果你的比较函数`cmp`定义如下：

```cpp
bool cmp(int a, int b) {
    return a > b;
}
```

这意味着你告诉`std::sort`，对于任意两个元素`a`和`b`，如果`a`应该排在`b`之后（即`a`大于`b`），则返回`true`。换句话说，这个比较函数定义了一个降序排序的规则：较大的数排在较小的数之后。

例如，如果你有一个整数数组`arr`，并且你想使用这个`cmp`函数来对它进行排序，代码如下：

```cpp
#include <algorithm> // 包含std::sort
#include <vector>

bool cmp(int a, int b) {
    return a > b; // 降序排序
}

int main() {
    std::vector<int> arr = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5};
    std::sort(arr.begin(), arr.end(), cmp);
    // 现在arr被排序为：{9, 6, 5, 5, 5, 4, 3, 3, 2, 1, 1}
    return 0;
}
```

在这个例子中，`std::sort`会使用`cmp`函数来比较数组中的元素，并按照降序排列它们。所以，数组`arr`最终会被排序成一个降序数组。

在C++中，`std::sort`函数的第三个参数是一个比较函数，它接受两个参数并返回一个布尔值。这个返回的布尔值表示排序的逻辑关系：

- 如果返回`true`，则表示第一个参数应该排在第二个参数的后面。
- 如果返回`false`，则表示第一个参数应该排在第二个参数的前面。

所以，当你的比较函数`cmp`定义为：

```cpp
bool cmp(int a, int b) {
    return a > b;
}
```

这里的逻辑是：

- 当`a > b`为`true`时，即`a`大于`b`，`cmp`函数返回`true`，表示`a`应该排在`b`的后面。
- 当`a > b`为`false`时，即`a`不大于`b`（也就是`a`小于或等于`b`），`cmp`函数返回`false`，表示`a`不应该排在`b`的后面，即`a`应该排在`b`的前面。

以一个具体的例子来说明：

假设我们有三个元素：`1`，`3`，`2`。

- `cmp(1, 3)`返回`false`，因为`1`不大于`3`，所以`1`应该排在`3`的前面。
- `cmp(3, 2)`返回`true`，因为`3`大于`2`，所以`3`应该排在`2`的后面。
- `cmp(2, 1)`返回`true`，因为`2`大于`1`，所以`2`应该排在`1`的后面。

按照这个逻辑，最终的排序结果是降序：`3`，`2`，`1`。

所以，`return a > b;`的意思是，如果`a`大于`b`，返回`true`，表示`a`应该排在`b`后面；如果`a`不大于`b`，返回`false`，表示`a`应该排在`b`前面。这样，通过比较函数的逻辑，`std::sort`函数就可以按照你定义的规则对元素进行排序。